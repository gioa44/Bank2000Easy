CREATE TABLE [impexp].[DOCS_IN_SWIFT]
(
[PORTION_DATE] [smalldatetime] NOT NULL,
[PORTION] [int] NOT NULL,
[ROW_ID] [int] NOT NULL,
[UID] [int] NOT NULL CONSTRAINT [DF_DOCS_IN_SWIFT_UID] DEFAULT ((0)),
[REF_NUM] [varchar] (32) COLLATE Latin1_General_BIN NOT NULL,
[DATE] [smalldatetime] NOT NULL,
[ISO] [dbo].[TISO] NOT NULL,
[AMOUNT] [money] NOT NULL,
[DESCRIP] [varchar] (150) COLLATE Latin1_General_BIN NULL,
[SENDER_BANK_CODE] [varchar] (37) COLLATE Latin1_General_BIN NOT NULL,
[SENDER_BANK_NAME] [varchar] (105) COLLATE Latin1_General_BIN NULL,
[SENDER_ACC] [varchar] (37) COLLATE Latin1_General_BIN NOT NULL,
[SENDER_ACC_NAME] [varchar] (105) COLLATE Latin1_General_BIN NULL,
[RECEIVER_BANK_CODE] [varchar] (37) COLLATE Latin1_General_BIN NOT NULL,
[RECEIVER_BANK_NAME] [varchar] (105) COLLATE Latin1_General_BIN NULL,
[RECEIVER_ACC] [varchar] (37) COLLATE Latin1_General_BIN NOT NULL,
[RECEIVER_ACC_NAME] [varchar] (105) COLLATE Latin1_General_BIN NULL,
[INTERMED_BANK_CODE] [varchar] (37) COLLATE Latin1_General_BIN NULL,
[INTERMED_BANK_NAME] [varchar] (105) COLLATE Latin1_General_BIN NULL,
[COR_BANK_CODE] [varchar] (37) COLLATE Latin1_General_BIN NULL,
[COR_BANK_NAME] [varchar] (100) COLLATE Latin1_General_BIN NULL,
[CORRESPONDENT_BANK_ID] [int] NULL,
[COR_COUNTRY] [char] (2) COLLATE Latin1_General_BIN NULL,
[TAG_53X_STATUS] [char] (1) COLLATE Latin1_General_BIN NULL,
[TAG_53X_VALUE] [varchar] (37) COLLATE Latin1_General_BIN NULL,
[TAG_54X_STATUS] [char] (1) COLLATE Latin1_General_BIN NULL,
[TAG_54X_VALUE] [varchar] (35) COLLATE Latin1_General_BIN NULL,
[EXTRA_INFO] [varchar] (255) COLLATE Latin1_General_BIN NULL,
[EXTRA_INFO_DESCRIP] [bit] NOT NULL,
[DET_OF_CHARG] [char] (3) COLLATE Latin1_General_BIN NULL,
[SWIFT_TEXT] [text] COLLATE Latin1_General_BIN NULL,
[STATE] [int] NOT NULL,
[IS_READY] [bit] NOT NULL CONSTRAINT [DF_DOCS_IN_SWIFT_IS_READY] DEFAULT ((0)),
[IS_FINALYZED] [bit] NOT NULL CONSTRAINT [DF_DOCS_IN_SWIFT_IS_FINALYZED] DEFAULT ((0)),
[ACCOUNT] [dbo].[TACCOUNT] NULL,
[ACC_ID] [int] NULL,
[OTHER_INFO] [varchar] (250) COLLATE Latin1_General_BIN NULL,
[ERROR_REASON] [varchar] (100) COLLATE Latin1_General_BIN NULL,
[DOC_DATE] [smalldatetime] NULL,
[SWIFT_FILE_ROW_ID] [int] NOT NULL,
[SWIFT_FILENAME] [varchar] (100) COLLATE Latin1_General_BIN NOT NULL,
[FINALYZE_DATE] [smalldatetime] NULL,
[FINALYZE_BANK_ID] [int] NULL,
[FINALYZE_ACC_ID] [int] NULL,
[FINALYZE_AMOUNT] [money] NULL,
[FINALYZE_ISO] [dbo].[TISO] NULL,
[FINALYZE_DOC_REC_ID] [int] NULL,
[DOC_REC_ID] [int] NULL,
[IS_AUTHORIZED] [bit] NOT NULL CONSTRAINT [DF_DOCS_IN_SWIFT_IS_AUTHORIZED] DEFAULT ((0)),
[IS_MODIFIED] [bit] NOT NULL CONSTRAINT [DF_DOCS_IN_SWIFT_IS_MODIFIED] DEFAULT ((0))
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE TRIGGER [impexp].[ON_DOCS_IN_SWIFT_UPDATE] ON [impexp].[DOCS_IN_SWIFT]
INSTEAD OF INSERT,DELETE,UPDATE
AS 
BEGIN
	SET NOCOUNT ON;

	DECLARE
		@portion_date smalldatetime, 
		@portion int,
		@amount money,
		@count int,
		@processed_amount money,
		@processed_count int


	DECLARE cc CURSOR LOCAL FORWARD_ONLY
	FOR

	SELECT PORTION_DATE, PORTION, SUM(AMOUNT), SUM ([COUNT]), SUM(PROCESSED_AMOUNT), SUM (PROCESSED_COUNT)
	FROM 
		(	SELECT PORTION_DATE, PORTION, AMOUNT AS AMOUNT, 1 AS [COUNT],
				CASE WHEN STATE IN (4, 99) THEN AMOUNT ELSE $0.0 END AS PROCESSED_AMOUNT,
				CASE WHEN STATE IN (4, 99) THEN 1 ELSE 0 END AS PROCESSED_COUNT FROM inserted
			UNION ALL
			SELECT PORTION_DATE, PORTION, -AMOUNT AS AMOUNT, -1 AS [COUNT],
				CASE WHEN STATE IN (4, 99) THEN -AMOUNT ELSE $0.0 END AS PROCESSED_AMOUNT,
				CASE WHEN STATE IN (4, 99) THEN -1 ELSE 0 END AS PROCESSED_COUNT FROM deleted
		) A
	GROUP BY PORTION_DATE, PORTION
	
	OPEN cc
	FETCH NEXT FROM cc INTO @portion_date, @portion, @amount, @count, @processed_amount, @processed_count
	
	WHILE @@FETCH_STATUS = 0 
	BEGIN
--		IF @portion_date < dbo.bank_open_date()
--		BEGIN
--			RAISERROR ('ÞÅÄËÉ ÈÀÒÉÙÉÈ ÐÏÒÝÉÀÓÈÀÍ ÌÏØÌÄÃÄÁÀ ÀÒ ÛÄÉÞËÄÁÀ',16,1)
--			ROLLBACK
--			RETURN
--		END

		IF NOT EXISTS(SELECT * FROM impexp.PORTIONS_IN_SWIFT WHERE PORTION_DATE = @portion_date AND PORTION = @portion)
		BEGIN
			INSERT INTO impexp.PORTIONS_IN_SWIFT (PORTION_DATE, PORTION, STATE, AMOUNT, RECV_TIME)
			VALUES (@portion_date, @portion, 1, $0.00, getdate())

			IF @@ERROR <> 0 BEGIN ROLLBACK RETURN END
		END

		UPDATE impexp.PORTIONS_IN_SWIFT
		SET AMOUNT = AMOUNT + @amount, 
			[COUNT] = [COUNT] + @count,
			PROCESSED_AMOUNT = PROCESSED_AMOUNT + @processed_amount, 
			PROCESSED_COUNT = PROCESSED_COUNT + @processed_count,
			STATE = CASE WHEN PROCESSED_COUNT + @processed_count > 0 AND PROCESSED_COUNT + @processed_count = [COUNT] + @count THEN 4 ELSE 2 END,
			FINISH_TIME = CASE WHEN PROCESSED_COUNT + @processed_count > 0 AND PROCESSED_COUNT + @processed_count = [COUNT] + @count THEN GETDATE() ELSE FINISH_TIME END
		WHERE PORTION_DATE = @portion_date AND PORTION = @portion

		FETCH NEXT FROM cc INTO @portion_date, @portion, @amount, @count, @processed_amount, @processed_count
	END

	DELETE A
	FROM impexp.DOCS_IN_SWIFT A
		INNER JOIN deleted ON deleted.PORTION_DATE = A.PORTION_DATE AND deleted.PORTION = A.PORTION AND deleted.ROW_ID = A.ROW_ID

	INSERT INTO impexp.DOCS_IN_SWIFT
	SELECT * FROM inserted
END
GO
ALTER TABLE [impexp].[DOCS_IN_SWIFT] ADD CONSTRAINT [PK_DOCS_IN_SWIFT] PRIMARY KEY CLUSTERED  ([PORTION_DATE], [PORTION], [ROW_ID]) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [IX_DOCS_IN_SWIFT_DOC_REC_ID] ON [impexp].[DOCS_IN_SWIFT] ([DOC_REC_ID]) ON [PRIMARY]
GO
ALTER TABLE [impexp].[DOCS_IN_SWIFT] ADD CONSTRAINT [FK_DOCS_IN_SWIFT_PORTIONS_IN_SWIFT] FOREIGN KEY ([PORTION_DATE], [PORTION]) REFERENCES [impexp].[PORTIONS_IN_SWIFT] ([PORTION_DATE], [PORTION])
GO
